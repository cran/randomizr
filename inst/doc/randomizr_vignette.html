<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Alexander Coppock" />

<meta name="date" content="2015-11-23" />

<title>Design and Analysis of Experiments with Randomizr</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link href="data:text/css,body%20%7B%0A%20%20background%2Dcolor%3A%20%23fff%3B%0A%20%20margin%3A%201em%20auto%3B%0A%20%20max%2Dwidth%3A%20700px%3B%0A%20%20overflow%3A%20visible%3B%0A%20%20padding%2Dleft%3A%202em%3B%0A%20%20padding%2Dright%3A%202em%3B%0A%20%20font%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0A%20%20font%2Dsize%3A%2014px%3B%0A%20%20line%2Dheight%3A%201%2E35%3B%0A%7D%0A%0A%23header%20%7B%0A%20%20text%2Dalign%3A%20center%3B%0A%7D%0A%0A%23TOC%20%7B%0A%20%20clear%3A%20both%3B%0A%20%20margin%3A%200%200%2010px%2010px%3B%0A%20%20padding%3A%204px%3B%0A%20%20width%3A%20400px%3B%0A%20%20border%3A%201px%20solid%20%23CCCCCC%3B%0A%20%20border%2Dradius%3A%205px%3B%0A%0A%20%20background%2Dcolor%3A%20%23f6f6f6%3B%0A%20%20font%2Dsize%3A%2013px%3B%0A%20%20line%2Dheight%3A%201%2E3%3B%0A%7D%0A%20%20%23TOC%20%2Etoctitle%20%7B%0A%20%20%20%20font%2Dweight%3A%20bold%3B%0A%20%20%20%20font%2Dsize%3A%2015px%3B%0A%20%20%20%20margin%2Dleft%3A%205px%3B%0A%20%20%7D%0A%0A%20%20%23TOC%20ul%20%7B%0A%20%20%20%20padding%2Dleft%3A%2040px%3B%0A%20%20%20%20margin%2Dleft%3A%20%2D1%2E5em%3B%0A%20%20%20%20margin%2Dtop%3A%205px%3B%0A%20%20%20%20margin%2Dbottom%3A%205px%3B%0A%20%20%7D%0A%20%20%23TOC%20ul%20ul%20%7B%0A%20%20%20%20margin%2Dleft%3A%20%2D2em%3B%0A%20%20%7D%0A%20%20%23TOC%20li%20%7B%0A%20%20%20%20line%2Dheight%3A%2016px%3B%0A%20%20%7D%0A%0Atable%20%7B%0A%20%20margin%3A%201em%20auto%3B%0A%20%20border%2Dwidth%3A%201px%3B%0A%20%20border%2Dcolor%3A%20%23DDDDDD%3B%0A%20%20border%2Dstyle%3A%20outset%3B%0A%20%20border%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0A%20%20border%2Dwidth%3A%202px%3B%0A%20%20padding%3A%205px%3B%0A%20%20border%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0A%20%20border%2Dwidth%3A%201px%3B%0A%20%20border%2Dstyle%3A%20inset%3B%0A%20%20line%2Dheight%3A%2018px%3B%0A%20%20padding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0A%20%20border%2Dleft%2Dstyle%3A%20none%3B%0A%20%20border%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0A%0Ap%20%7B%0A%20%20margin%3A%200%2E5em%200%3B%0A%7D%0A%0Ablockquote%20%7B%0A%20%20background%2Dcolor%3A%20%23f6f6f6%3B%0A%20%20padding%3A%200%2E25em%200%2E75em%3B%0A%7D%0A%0Ahr%20%7B%0A%20%20border%2Dstyle%3A%20solid%3B%0A%20%20border%3A%20none%3B%0A%20%20border%2Dtop%3A%201px%20solid%20%23777%3B%0A%20%20margin%3A%2028px%200%3B%0A%7D%0A%0Adl%20%7B%0A%20%20margin%2Dleft%3A%200%3B%0A%7D%0A%20%20dl%20dd%20%7B%0A%20%20%20%20margin%2Dbottom%3A%2013px%3B%0A%20%20%20%20margin%2Dleft%3A%2013px%3B%0A%20%20%7D%0A%20%20dl%20dt%20%7B%0A%20%20%20%20font%2Dweight%3A%20bold%3B%0A%20%20%7D%0A%0Aul%20%7B%0A%20%20margin%2Dtop%3A%200%3B%0A%7D%0A%20%20ul%20li%20%7B%0A%20%20%20%20list%2Dstyle%3A%20circle%20outside%3B%0A%20%20%7D%0A%20%20ul%20ul%20%7B%0A%20%20%20%20margin%2Dbottom%3A%200%3B%0A%20%20%7D%0A%0Apre%2C%20code%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20color%3A%20%23333%3B%0A%7D%0Apre%20%7B%0A%20%20white%2Dspace%3A%20pre%2Dwrap%3B%20%20%20%20%2F%2A%20Wrap%20long%20lines%20%2A%2F%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20margin%3A%205px%200px%2010px%200px%3B%0A%20%20padding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0A%0Acode%20%7B%0A%20%20font%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0A%20%20font%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0A%20%20padding%3A%202px%200px%3B%0A%7D%0A%0Adiv%2Efigure%20%7B%0A%20%20text%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0A%20%20background%2Dcolor%3A%20%23FFFFFF%3B%0A%20%20padding%3A%202px%3B%0A%20%20border%3A%201px%20solid%20%23DDDDDD%3B%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20border%3A%201px%20solid%20%23CCCCCC%3B%0A%20%20margin%3A%200%205px%3B%0A%7D%0A%0Ah1%20%7B%0A%20%20margin%2Dtop%3A%200%3B%0A%20%20font%2Dsize%3A%2035px%3B%0A%20%20line%2Dheight%3A%2040px%3B%0A%7D%0A%0Ah2%20%7B%0A%20%20border%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0A%20%20padding%2Dtop%3A%2010px%3B%0A%20%20padding%2Dbottom%3A%202px%3B%0A%20%20font%2Dsize%3A%20145%25%3B%0A%7D%0A%0Ah3%20%7B%0A%20%20border%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0A%20%20padding%2Dtop%3A%2010px%3B%0A%20%20font%2Dsize%3A%20120%25%3B%0A%7D%0A%0Ah4%20%7B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0A%20%20margin%2Dleft%3A%208px%3B%0A%20%20font%2Dsize%3A%20105%25%3B%0A%7D%0A%0Ah5%2C%20h6%20%7B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23ccc%3B%0A%20%20font%2Dsize%3A%20105%25%3B%0A%7D%0A%0Aa%20%7B%0A%20%20color%3A%20%230033dd%3B%0A%20%20text%2Ddecoration%3A%20none%3B%0A%7D%0A%20%20a%3Ahover%20%7B%0A%20%20%20%20color%3A%20%236666ff%3B%20%7D%0A%20%20a%3Avisited%20%7B%0A%20%20%20%20color%3A%20%23800080%3B%20%7D%0A%20%20a%3Avisited%3Ahover%20%7B%0A%20%20%20%20color%3A%20%23BB00BB%3B%20%7D%0A%20%20a%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0A%20%20%20%20text%2Ddecoration%3A%20underline%3B%20%7D%0A%20%20a%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0A%20%20%20%20text%2Ddecoration%3A%20underline%3B%20%7D%0A%0A%2F%2A%20Class%20described%20in%20https%3A%2F%2Fbenjeffrey%2Ecom%2Fposts%2Fpandoc%2Dsyntax%2Dhighlighting%2Dcss%0A%20%20%20Colours%20from%20https%3A%2F%2Fgist%2Egithub%2Ecom%2Frobsimmons%2F1172277%20%2A%2F%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20Keyword%20%2A%2F%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%2F%2A%20DataType%20%2A%2F%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%2F%2A%20DecVal%20%28decimal%20values%29%20%2A%2F%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20BaseN%20%2A%2F%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20Float%20%2A%2F%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20Char%20%2A%2F%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20String%20%2A%2F%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%2F%2A%20Comment%20%2A%2F%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%2F%2A%20OtherToken%20%2A%2F%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20AlertToken%20%2A%2F%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20Function%20calls%20%2A%2F%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%2F%2A%20ErrorTok%20%2A%2F%0A%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div id="header">
<h1 class="title">Design and Analysis of Experiments with Randomizr</h1>
<h4 class="author"><em>Alexander Coppock</em></h4>
<h4 class="date"><em>2015-11-23</em></h4>
</div>


<p><code>randomizr</code> is a small package for r that simplifies the design and analysis of randomized experiments. In particular, it makes the random assignment <strong>procedure</strong> transparent, flexible, and most importantly reproduceable. By the time that many experiments are written up and made public, the process by which some units recieved treatments is lost or imprecisely described. The <code>randomizr</code> package makes it easy for even the most forgetful of researchers to generate error-free, reproduceable random assignments.</p>
<p>A hazy understanding of the random assignment procedure leads to two main problems at the analysis stage. First, units may have different probabilities of assignment to treatment. Analyzing the data as though they have the same probabilities of assignment leads to biased estimates of the treatment effect. Second, units are sometimes assigned to treatment as a <strong>cluster</strong>. For example, all the students in a single classroom may be assigned to the same intervention together. If the analysis ignores the clustering in the assignments, estimates of uncertainty may be incorrect.</p>
<div id="a-hypothetical-experiment" class="section level1">
<h1>A Hypothetical Experiment</h1>
<p>Throughout this vignette, we’ll pretend we’re conducting an experiment among the 592 individuals in the built-in <code>HairEyeColor</code> dataset. As we’ll see, there are many ways to randomly assign subjects to treatments. We’ll step through five common designs, each associated with one of the five <code>randomizr</code> functions: <code>simple_ra()</code>, <code>complete_ra()</code>, <code>block_ra()</code>, <code>cluster_ra()</code>, and <code>block_and_cluster_ra()</code>.</p>
<div id="setting-up-the-experiment" class="section level2">
<h2>Setting up the experiment</h2>
<p>We first need to transform the dataset, which has each row describe a <strong>type</strong> of subject, to a new dataset in which each row describes an individual subject.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load built-in dataset</span>
<span class="kw">data</span>(HairEyeColor)
HairEyeColor &lt;-<span class="st"> </span><span class="kw">data.frame</span>(HairEyeColor)

<span class="co"># Transform so each row is a subject</span>
<span class="co"># Columns describe subject's hair color, eye color, and gender</span>
hec &lt;-<span class="st"> </span>HairEyeColor[<span class="kw">rep</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(HairEyeColor),
                        <span class="dt">times =</span> HairEyeColor$Freq), <span class="dv">1</span>:<span class="dv">3</span>]

N &lt;-<span class="st"> </span><span class="kw">nrow</span>(hec)

<span class="co"># Fix the rownames</span>
<span class="kw">rownames</span>(hec) &lt;-<span class="st"> </span><span class="dv">1</span>:N</code></pre>
<p>Typically, researchers know some basic information about their subjects before deploying treatment. For example, they usually know how many subjects there are in the experimental sample (N), and they usually know some basic demographic information about each subject.</p>
<p>Our new dataset has 592 subjects. We have three pretreatment covariates, <code>Hair</code>, <code>Eye</code>, and <code>Sex</code>, which describe the hair color, eye color, and gender of each subject.</p>
<p>We now need to create simulated <em>potential outcomes</em>. We’ll call the untreated outcome <code>Y0</code> and we’ll call the treated outcome <code>Y1</code>. Imagine that in the absence of any intervention, the outcome (<code>Y0</code>) is correlated with out pretreatment covariates. Imagine further that the effectiveness of the program varies according to these covariates, i.e., the difference between <code>Y1</code> and <code>Y0</code> is correlated with the pretreatment covariates.</p>
<p>If we were really running an experiment, we would only observe either <code>Y0</code> or <code>Y1</code> for each subject, but since we are simulating, we generate both. Our inferential target is the average treatment effect (ATE), which is defined as the average difference between <code>Y0</code> and <code>Y1</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Set a seed for reproducability</span>
<span class="kw">set.seed</span>(<span class="dv">343</span>)

<span class="co"># Create untreated and treated outcomes for all subjects</span>
hec &lt;-<span class="st"> </span><span class="kw">within</span>(hec,{
  Y0 &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dt">n =</span> N,<span class="dt">mean =</span> (<span class="dv">2</span>*<span class="kw">as.numeric</span>(Hair) +<span class="st"> </span>-<span class="dv">4</span>*<span class="kw">as.numeric</span>(Eye) +<span class="st"> </span>-<span class="dv">6</span>*<span class="kw">as.numeric</span>(Sex)), <span class="dt">sd =</span> <span class="dv">5</span>)
  Y1 &lt;-<span class="st"> </span>Y0 +<span class="st"> </span><span class="dv">6</span>*<span class="kw">as.numeric</span>(Hair) +<span class="st"> </span><span class="dv">4</span>*<span class="kw">as.numeric</span>(Eye) +<span class="st"> </span><span class="dv">2</span>*<span class="kw">as.numeric</span>(Sex)
})

<span class="co"># Calculate true ATE</span>
<span class="kw">with</span>(hec, <span class="kw">mean</span>(Y1 -<span class="st"> </span>Y0))</code></pre>
<pre><code>## [1] 25.26351</code></pre>
<p>We are now ready to allocate treatment assignments to subjects. Let’s start by contrasting simple and complete random assignment.</p>
</div>
</div>
<div id="simple-random-assignment" class="section level1">
<h1>Simple Random Assignment</h1>
<p>Simple random assignment assigns all subjects to treatment with an equal probability by flipping a (weighted) coin for each subject. The main trouble with simple random assignment is that the number of subjects assigned to treatment is itself a random number - depending on the random assignment, a different number of subjects might be assigned to each group.</p>
<p>The <code>simple_ra()</code> function has one required argument <code>N</code>, the total number of subjects. If no other arguments are specified, <code>simple_ra()</code> assumes a two-group design and a 0.50 probability of assignment.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(randomizr)
Z &lt;-<span class="st"> </span><span class="kw">simple_ra</span>(<span class="dt">N =</span> N)
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##   0   1 
## 301 291</code></pre>
<p>To change the probability of assignment, specify the <code>prob</code> argument:</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">simple_ra</span>(<span class="dt">N =</span> N, <span class="dt">prob =</span> <span class="fl">0.30</span>)
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##   0   1 
## 402 190</code></pre>
<p>If you specify <code>num_arms</code> without changing <code>prob_each</code>, <code>simple_ra()</code> will assume equal probabilities across all arms.</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">simple_ra</span>(<span class="dt">N =</span> N, <span class="dt">num_arms =</span> <span class="dv">3</span>)
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##  T1  T2  T3 
## 186 191 215</code></pre>
<p>You can also just specify the probabilites of your multiple arms. The probabilities must sum to 1.</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">simple_ra</span>(<span class="dt">N =</span> N, <span class="dt">prob_each =</span> <span class="kw">c</span>(.<span class="dv">2</span>, .<span class="dv">2</span>, .<span class="dv">6</span>))
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##  T1  T2  T3 
## 125 111 356</code></pre>
<p>You can also name your treatment arms.</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">simple_ra</span>(<span class="dt">N =</span> N, <span class="dt">prob_each =</span> <span class="kw">c</span>(.<span class="dv">2</span>, .<span class="dv">2</span>, .<span class="dv">6</span>),
               <span class="dt">condition_names=</span><span class="kw">c</span>(<span class="st">&quot;control&quot;</span>, <span class="st">&quot;placebo&quot;</span>, <span class="st">&quot;treatment&quot;</span>))
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##   control   placebo treatment 
##       103       127       362</code></pre>
</div>
<div id="complete-random-assignment" class="section level1">
<h1>Complete Random Assignment</h1>
<p>Complete random assignment is very similar to simple random assignment, except that the researcher can specify <em>exactly</em> how many units are assigned to each condition.</p>
<p>The syntax for <code>complete_ra()</code> is very similar to that of <code>simple_ra()</code>. The argument <code>m</code> is the number of units assigned to treatment in two-arm designs; it is analogous to <code>simple_ra()</code>’s <code>prob</code>. Similarly, the argument <code>m_each</code> is analogous to <code>prob_each</code>.</p>
<p>If you only specify <code>N</code>, <code>complete_ra()</code> assigns exactly half of the subjects to treatment.</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">complete_ra</span>(<span class="dt">N =</span> N)
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##   0   1 
## 296 296</code></pre>
<p>To change the number of units assigned, specify the <code>m</code> argument:</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">complete_ra</span>(<span class="dt">N =</span> N, <span class="dt">m=</span><span class="dv">200</span>)
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##   0   1 
## 392 200</code></pre>
<p>If you specify multiple arms, <code>complete_ra()</code> will assign an equal (within rounding) number of units to treatment.</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">complete_ra</span>(<span class="dt">N =</span> N, <span class="dt">num_arms =</span> <span class="dv">3</span>)
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##  T1  T2  T3 
## 198 197 197</code></pre>
<p>You can also specify exactly how many units should be assigned to each arm. The total of <code>m_each</code> must equal <code>N</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">complete_ra</span>(<span class="dt">N =</span> N, <span class="dt">m_each =</span> <span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">292</span>))
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##  T1  T2  T3 
## 100 200 292</code></pre>
<p>You can also name your treatment arms.</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">complete_ra</span>(<span class="dt">N =</span> N, <span class="dt">m_each =</span> <span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">292</span>),
               <span class="dt">condition_names=</span><span class="kw">c</span>(<span class="st">&quot;control&quot;</span>, <span class="st">&quot;placebo&quot;</span>, <span class="st">&quot;treatment&quot;</span>))
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##   control   placebo treatment 
##       100       200       292</code></pre>
<div id="simple-and-complete-random-assignment-compared" class="section level2">
<h2>Simple and Complete Random Assignment Compared</h2>
<p>When should you use <code>simple_ra()</code> versus <code>complete_ra()</code>? Basically, if the number of units is known beforehand, <code>complete_ra()</code> is always preferred, for two reasons: 1. Researchers can plan exactly how many treatments will be deployed. 2. The standard errors associated with complete random assignment are generally smaller, increasing experimental power. See this guide on <a href="http://egap.org/">EGAP</a> for more on <a href="http://egap.org/resources/guides/power/">experimental power</a>.</p>
<p>Since you need to know <code>N</code> beforehand in order to use <code>simple_ra()</code>, it may seem like a useless function. Sometimes, however, the random assignment isn’t directly in the researcher’s control. For example, when deploying a survey exeriment on a platform like Qualtrics, simple random assignment is the only possibility due to the inflexibility of the built-in random assignment tools. When reconstructing the random assignment for analysis after the experiment has been conducted, <code>simple_ra()</code> provides a convenient way to do so.</p>
<p>To demonstrate how <code>complete_ra()</code> is superior to <code>simple_ra()</code>, let’s conduct a small simulation with our <code>HairEyeColor</code> dataset.</p>
<pre class="sourceCode r"><code class="sourceCode r">sims &lt;-<span class="st"> </span><span class="dv">1000</span>

<span class="co"># Set up empty vectors to collect results</span>
simple_ests &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, sims)
complete_ests &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, sims)

<span class="co"># Loop through simulation 2000 times</span>
for(i in <span class="dv">1</span>:sims){
  hec &lt;-<span class="st"> </span><span class="kw">within</span>(hec,{
    
    <span class="co"># Conduct both kinds of random assignment</span>
    Z_simple &lt;-<span class="st"> </span><span class="kw">simple_ra</span>(<span class="dt">N =</span> N)
    Z_complete &lt;-<span class="st"> </span><span class="kw">complete_ra</span>(<span class="dt">N =</span> N)
    
    <span class="co"># Reveal observed potential outcomes</span>
    Y_simple &lt;-<span class="st"> </span>Y1*Z_simple +<span class="st"> </span>Y0*(<span class="dv">1</span>-Z_simple)
    Y_complete &lt;-<span class="st"> </span>Y1*Z_complete +<span class="st"> </span>Y0*(<span class="dv">1</span>-Z_complete)
    })
  
  <span class="co"># Estimate ATE under both models</span>
  fit_simple &lt;-<span class="st"> </span><span class="kw">lm</span>(Y_simple ~<span class="st"> </span>Z_simple, <span class="dt">data=</span>hec)
  fit_complete &lt;-<span class="st"> </span><span class="kw">lm</span>(Y_complete ~<span class="st"> </span>Z_complete, <span class="dt">data=</span>hec)
  
  <span class="co"># Save the estimates</span>
  simple_ests[i] &lt;-<span class="st"> </span><span class="kw">coef</span>(fit_simple)[<span class="dv">2</span>]
  complete_ests[i] &lt;-<span class="st"> </span><span class="kw">coef</span>(fit_complete)[<span class="dv">2</span>]
}</code></pre>
<p>The standard error of an estimate is defined as the standard deviation of the sampling distribution of the estimator. When standard errors are estimated (i.e., by using the <code>summary()</code> command on a model fit), they are estimated using some approximation. This simulation allows us to measure the standard error directly, since the vectors <code>simple_ests</code> and <code>complete_ests</code> describe the sampling distribution of each design.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sd</span>(simple_ests)</code></pre>
<pre><code>## [1] 0.6245056</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sd</span>(complete_ests)</code></pre>
<pre><code>## [1] 0.596656</code></pre>
<p>In this simulation complete random assignment led to a 8.72% decrease in sampling variability. This decrease was obtained with a small design tweak that costs the researcher essentially nothing.</p>
</div>
</div>
<div id="block-random-assignment" class="section level1">
<h1>Block Random Assignment</h1>
<p>Block random assignment (sometimes known as stratified random assignment) is a powerful tool when used well. In this design, subjects are sorted into blocks (strata) according to their pre-treatment covariates, and then complete random assignment is conducted within each block. For example, a researcher might block on gender, assigning exactly half of the men and exactly half of the women to treatment.</p>
<p>Why block? The first reason is to signal to future readers that treatment effect heterogeneity may be of interest: is the treatment effect different for men versus women? Of course, such heterogeneity could be explored if complete random assignment had been used, but blocking on a covariate defends a researcher (somewhat) against claims of data dredging. The second reason is to increase precision. If the blocking variables are predicitive of the outcome (i.e., they are correlated with the outcome), then blocking may help to decrease sampling variability. It’s important, however, not to overstate these advantages. The gains from a blocked design can often be realized through covariate adjustment alone.</p>
<p>Blocking can also produce complications for estimation. Blocking can produce different probabilities of assignment for different subjects. This complication is typically addressed in one of two ways: “controlling for blocks” in a regression context, or inverse probabilitity weights (IPW), in which units are weighted by the inverse of the probability that the unit is in the condition that it is in.</p>
<p>The only required argument to <code>block_ra()</code> is <code>block_var</code>, which is a vector of length <code>N</code> that describes which block a unit belongs to. <code>block_var</code> can be a factor, character, or numeric variable. If no other arguments are specified, <code>block_ra()</code> assigns an approximately equal proportion of each block to treatment.</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">block_ra</span>(<span class="dt">block_var =</span> hec$Hair)
<span class="kw">table</span>(Z, hec$Hair)</code></pre>
<pre><code>##    
## Z   Black Brown Red Blond
##   0    54   143  36    64
##   1    54   143  35    63</code></pre>
<p>For multiple treatment arms, use the <code>num_arms</code> argument, with or without the <code>condition_names</code> argument</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">block_ra</span>(<span class="dt">block_var =</span> hec$Hair, <span class="dt">num_arms=</span><span class="dv">3</span>)
<span class="kw">table</span>(Z, hec$Hair)</code></pre>
<pre><code>##     
## Z    Black Brown Red Blond
##   T1    36    95  24    42
##   T2    36    95  23    42
##   T3    36    96  24    43</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">block_ra</span>(<span class="dt">block_var =</span> hec$Hair, <span class="dt">condition_names=</span><span class="kw">c</span>(<span class="st">&quot;Control&quot;</span>, <span class="st">&quot;Placebo&quot;</span>, <span class="st">&quot;Treatment&quot;</span>))
<span class="kw">table</span>(Z, hec$Hair)</code></pre>
<pre><code>##            
## Z           Black Brown Red Blond
##   Control      36    95  24    42
##   Placebo      36    95  24    42
##   Treatment    36    96  23    43</code></pre>
<p><code>block_ra()</code> provides a number of ways to adjust the number of subjects assigned to each conditions. The <code>prob_each</code> argument describes what proportion of each block should be assigned to treatment arm. Note of course, that <code>block_ra()</code> still uses complete random assignment within each block; the appropriate number of units to assign to treatment within each block is automatically determined.</p>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">block_ra</span>(<span class="dt">block_var =</span> hec$Hair,<span class="dt">prob_each =</span> <span class="kw">c</span>(.<span class="dv">3</span>, .<span class="dv">7</span>))
<span class="kw">table</span>(Z, hec$Hair)</code></pre>
<pre><code>##    
## Z   Black Brown Red Blond
##   0    33    85  22    38
##   1    75   201  49    89</code></pre>
<p>For finer control, use the <code>block_m</code> argument, which takes a matrix with as many rows as there are blocks, and as many columns as there are treatment conditions. Remember that the rows are in the same order as <code>sort(unique(block_var))</code>, a command that is good to run before constructing a <code>block_m</code> matrix.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sort</span>(<span class="kw">unique</span>(hec$Hair))</code></pre>
<pre><code>## [1] Black Brown Red   Blond
## Levels: Black Brown Red Blond</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">block_m &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">78</span>, <span class="dv">30</span>),
                 <span class="kw">c</span>(<span class="dv">186</span>, <span class="dv">100</span>),
                 <span class="kw">c</span>(<span class="dv">51</span>, <span class="dv">20</span>),
                 <span class="kw">c</span>(<span class="dv">87</span>,<span class="dv">40</span>))

block_m</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   78   30
## [2,]  186  100
## [3,]   51   20
## [4,]   87   40</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw">block_ra</span>(<span class="dt">block_var =</span> hec$Hair, <span class="dt">block_m =</span> block_m)
<span class="kw">table</span>(Z, hec$Hair)</code></pre>
<pre><code>##    
## Z   Black Brown Red Blond
##   0    78   186  51    87
##   1    30   100  20    40</code></pre>
<p>In the example above, the different blocks have different probabilities of assignment to treatment. In this case, people with Black hair have a 30/108 = 27.8% chance of being treated, those with Brown hair have 100/286 = 35.0% change, etc. Left unadressed, this discrepancy could bias treatment effects. We can see this directly with the <code>declare_ra()</code> function.</p>
<pre class="sourceCode r"><code class="sourceCode r">declaration &lt;-<span class="st"> </span><span class="kw">declare_ra</span>(<span class="dt">block_var =</span> hec$Hair, <span class="dt">block_m =</span> block_m)

<span class="co"># show the probability that each unit is assigned to each condition</span>
<span class="kw">head</span>(declaration$probabilities_matrix)</code></pre>
<pre><code>##         prob_0    prob_1
## [1,] 0.7222222 0.2777778
## [2,] 0.7222222 0.2777778
## [3,] 0.7222222 0.2777778
## [4,] 0.7222222 0.2777778
## [5,] 0.7222222 0.2777778
## [6,] 0.7222222 0.2777778</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Show that the probability of treatment is different within block</span>
<span class="kw">table</span>(hec$Hair, <span class="kw">round</span>(declaration$probabilities_matrix[,<span class="dv">2</span>], <span class="dv">3</span>))</code></pre>
<pre><code>##        
##         0.278 0.282 0.315 0.35
##   Black   108     0     0    0
##   Brown     0     0     0  286
##   Red       0    71     0    0
##   Blond     0     0   127    0</code></pre>
<p>There are commong two ways to address this problem: LSDV (Least-Squares Dummy Variable, also known as “control for blocks”) or IPW (Inverse-probability weights).</p>
<p>The following code snippet shows how to use either the LSDV approach or the IPW approach. A note for scrupulous readers: the estimands of these two approaches are subtly different from one another. The LSDV approach estimates the average <strong>block-level</strong> treatment effect. The IPW approach estimates the average <strong>individual-level</strong> treatment effect. They can be different. Since the average block-level treatment effect is not what most people have in mind when thinking about causal effects, analysts using this approach should present both. The <code>condition_probs()</code> function used to calculate the probabilities of assignment is explained below.</p>
<pre class="sourceCode r"><code class="sourceCode r">hec &lt;-<span class="st"> </span><span class="kw">within</span>(hec,{
  Z_blocked &lt;-<span class="st"> </span><span class="kw">block_ra</span>(<span class="dt">block_var =</span> hec$Hair,<span class="dt">block_m=</span>block_m, <span class="dt">condition_names =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>))
  Y_blocked &lt;-<span class="st"> </span>Y1*(Z_blocked) +<span class="st"> </span>Y0*(<span class="dv">1</span>-Z_blocked)
  cond_prob &lt;-<span class="st"> </span><span class="kw">obtain_condition_probabilities</span>(declaration, Z_blocked)
  IPW_weights &lt;-<span class="st"> </span><span class="dv">1</span>/(cond_prob)
})

fit_LSDV &lt;-<span class="st"> </span><span class="kw">lm</span>(Y_blocked ~<span class="st"> </span>Z_blocked +<span class="st"> </span>Hair, <span class="dt">data=</span>hec)
fit_IPW &lt;-<span class="st"> </span><span class="kw">lm</span>(Y_blocked ~<span class="st"> </span>Z_blocked, <span class="dt">weights=</span>IPW_weights, <span class="dt">data=</span>hec)

<span class="kw">summary</span>(fit_LSDV)</code></pre>
<pre><code>## 
## Call:
## lm(formula = Y_blocked ~ Z_blocked + Hair, data = hec)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -22.1086  -4.2795   0.3799   4.6342  18.6040 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -16.2037     0.6855 -23.639  &lt; 2e-16 ***
## Z_blocked    24.9493     0.6090  40.965  &lt; 2e-16 ***
## HairBrown     2.3447     0.7809   3.003  0.00279 ** 
## HairRed       5.8248     1.0547   5.523 5.02e-08 ***
## HairBlond     9.3325     0.9039  10.325  &lt; 2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 6.903 on 587 degrees of freedom
## Multiple R-squared:  0.7555, Adjusted R-squared:  0.7539 
## F-statistic: 453.5 on 4 and 587 DF,  p-value: &lt; 2.2e-16</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(fit_IPW)</code></pre>
<pre><code>## 
## Call:
## lm(formula = Y_blocked ~ Z_blocked, data = hec, weights = IPW_weights)
## 
## Weighted Residuals:
##     Min      1Q  Median      3Q     Max 
## -41.038  -6.768   0.114   6.872  41.074 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -12.3758     0.4691  -26.38   &lt;2e-16 ***
## Z_blocked    24.9021     0.6634   37.54   &lt;2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 11.41 on 590 degrees of freedom
## Multiple R-squared:  0.7048, Adjusted R-squared:  0.7043 
## F-statistic:  1409 on 1 and 590 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>How to create blocks? In the <code>HairEyeColor</code> dataset, we could make blocks for each unique combination of hair color, eye color, and sex using <code>dplyr</code>’s <code>id</code> function:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">suppressMessages</span>(<span class="kw">library</span>(dplyr))
block_id &lt;-<span class="st"> </span><span class="kw">id</span>(hec[,<span class="kw">c</span>(<span class="st">&quot;Hair&quot;</span>, <span class="st">&quot;Eye&quot;</span>, <span class="st">&quot;Sex&quot;</span>)])
block_var &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;block_&quot;</span>, <span class="kw">sprintf</span>(<span class="st">&quot;%02d&quot;</span>, block_id))
<span class="kw">table</span>(block_var)</code></pre>
<pre><code>## block_var
## block_01 block_02 block_03 block_04 block_05 block_06 block_07 block_08 
##       32       36       11        9       10        5        3        2 
## block_09 block_10 block_11 block_12 block_13 block_14 block_15 block_16 
##       53       66       50       34       25       29       15       14 
## block_17 block_18 block_19 block_20 block_21 block_22 block_23 block_24 
##       10       16       10        7        7        7        7        7 
## block_25 block_26 block_27 block_28 block_29 block_30 block_31 block_32 
##        3        4       30       64        5        5        8        8</code></pre>
<p>An alternative is to use the <code>blockTools</code> package, which constructs matched pairs, trios, quartets, etc. from pretreatment covariates.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(blockTools)

<span class="co"># BlockTools requires that all variables be numeric</span>
numeric_mat &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(~Hair+Eye+Sex, <span class="dt">data=</span>hec)[,-<span class="dv">1</span>]

<span class="co"># BlockTools also requres an id variable</span>
df_forBT &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">id_var =</span> <span class="dv">1</span>:<span class="kw">nrow</span>(numeric_mat), numeric_mat)

<span class="co"># Conducting the actual blocking: let's make trios</span>
out &lt;-<span class="st"> </span><span class="kw">block</span>(df_forBT, <span class="dt">n.tr =</span> <span class="dv">3</span>, <span class="dt">id.vars =</span> <span class="st">&quot;id_var&quot;</span>, 
             <span class="dt">block.vars =</span> <span class="kw">colnames</span>(df_forBT)[-<span class="dv">1</span>])

<span class="co"># Extact the block_ids</span>
hec$block_id &lt;-<span class="st"> </span><span class="kw">createBlockIDs</span>(out, df_forBT, <span class="dt">id.var =</span> <span class="st">&quot;id_var&quot;</span>)

<span class="co"># Conduct actual random assignment with randomizr</span>
Z_blocked &lt;-<span class="st"> </span><span class="kw">block_ra</span>(<span class="dt">block_var =</span> hec$block_id, <span class="dt">num_arms =</span> <span class="dv">3</span>)
<span class="kw">head</span>(<span class="kw">table</span>(hec$block_id, Z_blocked))</code></pre>
<pre><code>##    Z_blocked
##     T1 T2 T3
##   1  1  1  1
##   2  1  1  1
##   3  1  1  1
##   4  1  1  1
##   5  1  1  1
##   6  1  1  1</code></pre>
<p>A note for <code>blockTools</code> users: that package also has an assignment function. My preference is to extract the blocking variable, then conduct the assignment with <code>block_ra()</code>, so that fewer steps are required to reconstruct the random assignment or generate new random assignments for a randomization inference procedure.</p>
</div>
<div id="clustered-assignment" class="section level1">
<h1>Clustered assignment</h1>
<p>Clustered assignment is unfortunate. If you can avoid assigning subjects to treatments by cluster, you should. Sometimes, clustered assignment is unavoidable. Some common situations include:</p>
<ol style="list-style-type: decimal">
<li>Housemates in households: whole households are assigned to treatment or control</li>
<li>Students in classrooms: whole classrooms are assigned to treatment or control</li>
<li>Residents in towns or villages: whole communities are assigned to treatment or control</li>
</ol>
<p>Clustered assignment decreases the effective sample size of an experiment. In the extreme case when outcomes are perfectly correlated with clusters, the experiment has an effective sample size equal to the number of clusters. When outcomes are perfectly uncorrelated with clusters, the effective sample size is equal to the number of subjects. Almost all cluster-assigned experiments fall somewhere in the middle of these two extremes.</p>
<p>The only required argument for the <code>cluster_ra()</code> function is the <code>clust_var</code> argument, which is a vector of length <code>N</code> that indicates which cluster each subject belongs to. Let’s pretend that for some reason, we have to assign treatments according to the unique combinations of hair color, eye color, and gender. For this, we’ll use <code>dplyr</code>’s <code>id()</code> function again.</p>
<pre class="sourceCode r"><code class="sourceCode r">clust_id &lt;-<span class="st"> </span><span class="kw">id</span>(hec[,<span class="kw">c</span>(<span class="st">&quot;Hair&quot;</span>, <span class="st">&quot;Eye&quot;</span>, <span class="st">&quot;Sex&quot;</span>)])
clust_var &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;clust_&quot;</span>, <span class="kw">sprintf</span>(<span class="st">&quot;%02d&quot;</span>, clust_id))
hec$clust_var &lt;-<span class="st"> </span>clust_var

Z_clust &lt;-<span class="st"> </span><span class="kw">cluster_ra</span>(<span class="dt">clust_var =</span> clust_var)
<span class="kw">head</span>(<span class="kw">table</span>(clust_var, Z_clust))</code></pre>
<pre><code>##           Z_clust
## clust_var   0  1
##   clust_01 32  0
##   clust_02 36  0
##   clust_03  0 11
##   clust_04  0  9
##   clust_05  0 10
##   clust_06  0  5</code></pre>
<p>This shows that each cluster is either assigned to treatment or control. No two units within the same cluster are assigned to different conditions.</p>
<p>As with all functions in <code>randomizr</code>, you can specify multiple treatment arms in a variety of ways:</p>
<pre class="sourceCode r"><code class="sourceCode r">Z_clust &lt;-<span class="st"> </span><span class="kw">cluster_ra</span>(<span class="dt">clust_var=</span>clust_var, <span class="dt">num_arms=</span><span class="dv">3</span>)
<span class="kw">head</span>(<span class="kw">table</span>(clust_var, Z_clust))</code></pre>
<pre><code>##           Z_clust
## clust_var  T1 T2 T3
##   clust_01  0  0 32
##   clust_02 36  0  0
##   clust_03 11  0  0
##   clust_04  0  0  9
##   clust_05  0  0 10
##   clust_06  5  0  0</code></pre>
<p>… or using <code>condition_names</code></p>
<pre class="sourceCode r"><code class="sourceCode r">Z_clust &lt;-<span class="st"> </span><span class="kw">cluster_ra</span>(<span class="dt">clust_var=</span>clust_var, 
                      <span class="dt">condition_names=</span><span class="kw">c</span>(<span class="st">&quot;Control&quot;</span>, <span class="st">&quot;Placebo&quot;</span>, <span class="st">&quot;Treatment&quot;</span>))
<span class="kw">head</span>(<span class="kw">table</span>(clust_var, Z_clust))</code></pre>
<pre><code>##           Z_clust
## clust_var  Control Placebo Treatment
##   clust_01      32       0         0
##   clust_02       0       0        36
##   clust_03       0       0        11
##   clust_04       0       0         9
##   clust_05       0      10         0
##   clust_06       0       5         0</code></pre>
<p>… or using <code>m_each</code>, which describes how many clusters should be assigned to each condition. <code>m_each</code> must sum to the number of clusters.</p>
<pre class="sourceCode r"><code class="sourceCode r">Z_clust &lt;-<span class="st"> </span><span class="kw">cluster_ra</span>(<span class="dt">clust_var=</span>clust_var, <span class="dt">m_each=</span><span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">15</span>, <span class="dv">12</span>))
<span class="kw">head</span>(<span class="kw">table</span>(clust_var, Z_clust))</code></pre>
<pre><code>##           Z_clust
## clust_var  T1 T2 T3
##   clust_01  0 32  0
##   clust_02 36  0  0
##   clust_03  0 11  0
##   clust_04  0  9  0
##   clust_05  0  0 10
##   clust_06  0  0  5</code></pre>
</div>
<div id="blocked-and-clustered-assignment" class="section level1">
<h1>Blocked and clustered assignment</h1>
<p>The power of clustered experiments can sometimes be improved through blocking. In this scenario, whole clusters are members of a particular block – imagine villages nested within discrete regions, or classrooms nested within discrete schools.</p>
<p>As an example, let’s group our clusters into blocks by size:</p>
<pre class="sourceCode r"><code class="sourceCode r">cluster_level_df &lt;-<span class="st"> </span>
<span class="st">  </span>hec %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(clust_var) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">cluster_size =</span> <span class="kw">n</span>()) %&gt;%
<span class="st">  </span><span class="kw">arrange</span>(cluster_size) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">block_var =</span> <span class="kw">paste0</span>(<span class="st">&quot;block_&quot;</span>, <span class="kw">sprintf</span>(<span class="st">&quot;%02d&quot;</span>,<span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">16</span>, <span class="dt">each=</span><span class="dv">2</span>))))

hec &lt;-<span class="st"> </span><span class="kw">left_join</span>(hec, cluster_level_df)</code></pre>
<pre><code>## Joining by: &quot;clust_var&quot;</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Extract the cluster and block variables</span>
clust_var &lt;-<span class="st"> </span>hec$clust_var
block_var &lt;-<span class="st"> </span>hec$block_var

Z &lt;-<span class="st"> </span><span class="kw">block_and_cluster_ra</span>(<span class="dt">clust_var =</span> clust_var, <span class="dt">block_var =</span> block_var)
<span class="kw">head</span>(<span class="kw">table</span>(clust_var, Z))</code></pre>
<pre><code>##           Z
## clust_var   0  1
##   clust_01  0 32
##   clust_02  0 36
##   clust_03  0 11
##   clust_04  0  9
##   clust_05 10  0
##   clust_06  0  5</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">table</span>(block_var, Z))</code></pre>
<pre><code>##           Z
## block_var  0 1
##   block_01 3 2
##   block_02 3 4
##   block_03 5 5
##   block_04 5 7
##   block_05 7 7
##   block_06 7 7</code></pre>
</div>
<div id="calculating-probabilities-of-assignment" class="section level1">
<h1>Calculating probabilities of assignment</h1>
<p>All five random assignment functions in <code>randomizr</code> assign units to treatment with known (if sometimes complicated) probabilities. The <code>declare_ra()</code> and <code>obtain_condition_probabilities()</code> functions calculate these probabilities according to the parameters of your experimental design.</p>
<p>Let’s take a look at the block random assignment we used before.</p>
<pre class="sourceCode r"><code class="sourceCode r">block_m &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">c</span>(<span class="dv">78</span>, <span class="dv">186</span>, <span class="dv">51</span>, <span class="dv">87</span>),<span class="kw">c</span>(<span class="dv">30</span>, <span class="dv">100</span>, <span class="dv">20</span>, <span class="dv">40</span>))
Z &lt;-<span class="st"> </span><span class="kw">block_ra</span>(<span class="dt">block_var =</span> hec$Hair,<span class="dt">block_m=</span>block_m)
<span class="kw">table</span>(Z, hec$Hair)</code></pre>
<pre><code>##    
## Z   Black Brown Red Blond
##   0    78   186  51    87
##   1    30   100  20    40</code></pre>
<p>In order to calculate the probabilities of assignment, we call the <code>declare_ra()</code> function with the same exact arguments as we used for the <code>block_ra()</code> call. The <code>declaration</code> object contains a matrix of probabilities of assignment:</p>
<pre class="sourceCode r"><code class="sourceCode r">declaration &lt;-<span class="st"> </span><span class="kw">declare_ra</span>(<span class="dt">block_var =</span> hec$Hair,<span class="dt">block_m=</span>block_m)
prob_mat &lt;-<span class="st"> </span>declaration$probabilities_matrix

<span class="kw">head</span>(prob_mat)</code></pre>
<pre><code>##         prob_0    prob_1
## [1,] 0.7222222 0.2777778
## [2,] 0.7222222 0.2777778
## [3,] 0.7222222 0.2777778
## [4,] 0.7222222 0.2777778
## [5,] 0.7222222 0.2777778
## [6,] 0.7222222 0.2777778</code></pre>
<p>The <code>prob_mat</code> objects has <code>N</code> rows and as many columns as there are treatment conditions, in this case 2.</p>
<p>In order to use inverse-probability weights, we need to know the probability of each unit being in the <strong>condition that it is in</strong>. For each unit, we need to pick the appropriate probability. This bookkeeping is handled automatically by the <code>obtain_condition_probabilities()</code> function.</p>
<pre class="sourceCode r"><code class="sourceCode r">cond_prob &lt;-<span class="st"> </span><span class="kw">obtain_condition_probabilities</span>(declaration, Z)
<span class="kw">table</span>(cond_prob, Z)</code></pre>
<pre><code>##                    Z
## cond_prob             0   1
##   0.277777777777778   0  30
##   0.28169014084507    0  20
##   0.31496062992126    0  40
##   0.34965034965035    0 100
##   0.65034965034965  186   0
##   0.68503937007874   87   0
##   0.71830985915493   51   0
##   0.722222222222222  78   0</code></pre>
</div>
<div id="best-practices" class="section level1">
<h1>Best practices</h1>
<div id="random-assignment-procedure-random-assignment-function" class="section level2">
<h2>Random assignment procedure = Random assignment <strong>function</strong></h2>
<p>Random assignment procedures are often described as a series of steps that are manually carried out be the researcher. In order to make this procedure reproducible, these steps need to be translated into a <strong>function</strong> that returns a different random assignment each time it is called.</p>
<p>For example, consider the following procedure for randomly allocating school vouchers.</p>
<ol style="list-style-type: decimal">
<li>Every eligible student’s names is put on a list</li>
<li>Each name is assigned a random number</li>
<li>Balls with the numbers associated with all students are put in an urn.</li>
<li>Then the urn is “shuffled”</li>
<li>Students names are drawn one by one from the urn until all slots are given out.</li>
<li>If one sibling in a family wins, all other siblings automatically win too.</li>
</ol>
<p>If we write such a procedure into a function, it might look like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 400 families have 1 child in the lottery, 100 families have 2</span>
family_id &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%03d&quot;</span>, <span class="dv">1</span>:<span class="dv">500</span>), <span class="kw">sprintf</span>(<span class="st">&quot;%03d&quot;</span>, <span class="dv">1</span>:<span class="dv">100</span>))

school_ra &lt;-<span class="st"> </span>function(m){
  N &lt;-<span class="st"> </span><span class="kw">length</span>(family_id)
  random_number &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:N, <span class="dt">replace=</span><span class="ot">FALSE</span>)
  Z &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, N)
  i &lt;-<span class="st"> </span><span class="dv">1</span>
  while(<span class="kw">sum</span>(Z) &lt;m){
    Z[family_id==family_id[random_number[i]]] &lt;-<span class="st"> </span><span class="dv">1</span>
    i &lt;-<span class="st"> </span>i +<span class="st"> </span><span class="dv">1</span>
  }
  <span class="kw">return</span>(Z)
}

Z &lt;-<span class="st"> </span><span class="kw">school_ra</span>(<span class="dv">200</span>)
<span class="kw">table</span>(Z)</code></pre>
<pre><code>## Z
##   0   1 
## 400 200</code></pre>
<p>This assignment procedure is complicated by the sibling rule, which has two effects: first, students are cluster-assigned by family, and second, the probability of assignment varies student to student. Obviously, families who have two children in the lottery have a higher probability of winning the lottery because they effectively have two “tickets.” There may be better ways of running this assignment procedure (for example, with <code>cluster_ra()</code>), but the purpose of this example is to show how complicated <em>real-world</em> procedures can be written up in a simple function. With this function, the random assignment procedure can be reproduced exactly, the complicated probabilities of assignment can be caluculated, and the analysis is greatly simplified.</p>
</div>
<div id="check-probabilities-of-assignment-directly" class="section level2">
<h2>Check probabilities of assignment directly</h2>
<p>For many designs, the probability of assignment to treatment can be calculated analytically. For example, in a completely randomized design with 200 units, 60 of which are assigned to treatment, the probability is exactly 0.30 for all units. However, in more complicated designs (such as the schools example described above), analytic probabilities are difficult to calculate. In such a situation, an easy way to obtain the probabilities of assignment is through simulation.</p>
<ol style="list-style-type: decimal">
<li>Call your random assignment function an approximately infinite number of times (about 10,000 for most purposes).</li>
<li>Count how often each unit is assigned to each treatment arm.</li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r">Z_matrix &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">1000</span>, <span class="kw">school_ra</span>(<span class="dv">200</span>))
<span class="kw">plot</span>(<span class="kw">rowMeans</span>(Z_matrix))</code></pre>
<p><img src="data:image/png;base64,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iItAIBDoJwJBgPqJdrwrEAgEmhAIAtQER1wEAoFAPxEIAtRPtONdgUAg0IRAEKAmOOIiEAgE+olAEKB+oh3vCgQCgSYEggA1wREXgUAg0E8EggD1E+14VyAQCDQhEASoCY64CAQCgX4iEASon2jHuwKBQKAJgSBATXDERSAQCPQTgSBA/UQ73hUIBAJNCAQBaoIjLgKBQKCfCAQB6ifa8a5AIBBoQiAIUBMccREIBAL9RCAIUD/RjncFAoFAEwJBgJrgiItAIBDoJwJBgPqJdrwrEAgEmhAIAtQER1wEAoFAPxEIAtRPtONdgUAg0IRAEKAmOOIiEAgE+olAEKB+oh3vCgQCgSYEggA1wREXgUAg0E8EggD1E+14VyAQCDQhEASoCY64CAQCgX4iEASon2iP4LtuvPHGNN9886WTTz550rV73vOel4455phJ5xMZDA8CQYCG51tFSQOBkUMgCNDIfdKoUCAwPAgEARqebzU0JV177bXPYbi+AAAEhUlEQVTT+eefn3baaaf0yle+0n6zZ89OzzzzTKMOd955Z9p6663Tkksumd785jenCy64oHHPT/7617+mHXbYIc2YMSMttthiaaONNkp33XWX37b8eddf/vKXRtx+++2X3va2t6UHH3ywERcnA4xAjhAITAKBG264Iat553nz5jVyWXjhhfNSSy2VRQjysccem7fffntLc/DBB1uap59+Oovo5BVXXDGfeuqp+aijjsoiMJbm6KOPtjT/+Mc/8lve8pb8spe9LO+99975jDPOyG9/+9vz4osvnh966CFLc9NNN+UXvOAFeZdddrHrK664Is8///x57ty5dh1/g49AGvwiRgkHGYFOBGi11VZrKvYaa6yR3/Wud1mcBM35+c9/fv7973/fSHPSSSc1ESC/PueccxppnnjiifzCF74w77nnno24gw46KEt4na+88sq87LLL5nXWWSdDvCIMBwILDDBzFkUbYgRmzpzZVPplllkm3XzzzRZ33XXX2bTrFa94RSPNBz/4wSTupXF9+eWXpxe/+MVpoYUWSj//+c8b8SuttFLT9e67755OP/30JOKWFlhggXThhRfaqlzjgTgZaASCAA305xnewiGzKQZNlZI4E4u65ZZbTPZTvC+OKGm61YhCRvToo4+aPKcR+dwJMiEPLN1/5jOfSVtssYX9XvWqV/mtOA4BAv9/yBmCwkYRhwcBdIM6haWXXjo9/PDDY24/9thjjbiXvvSliXR///vfjXBBvPx3xx13NNI9+eSTad9997W0mrY1cUeNRHEysAgEARrYTzO6BXvTm96Urr322vTnP/+5Ucnrr78+Pf74443rFVZYwVa8fvnLX9qUCoImqUbafPPN02GHHdZIt9dee6V77703XXbZZUlC6jRr1qwEUYowHAgEARqO7zRSpWS6tOiiixqxuO+++9Jtt92Wttlmm6Y6brfddgkuaMcdd0xnnXWWEZk99tgjadXM5D0kRjakFa90wAEHJKZeWnEzogVRijAcCAQBGo7vNFKlhLCceeaZ6e67704vf/nL0/LLL5/e/e5327lXdJFFFkk/+clP7HLDDTdMCKwvuuiipCX7tPLKK6ennnrKCBg6RDvvvLOl0ypYmjNnjhGlouDa84zj4CEwH4t1g1esKNF0QeD++++3la4FF1ywY5WZqkFwUFqMMFoIBAEare8ZtQkEhgqBmIIN1eeKwgYCo4VAEKDR+p5Rm0BgqBAIAjRUnysKGwiMFgJBgEbre0ZtAoGhQiAI0FB9rihsIDBaCAQBGq3vGbUJBIYKgSBAQ/W5orCBwGghEARotL5n1CYQGCoEggAN1eeKwgYCo4VAEKDR+p5Rm0BgqBAIAjRUnysKGwiMFgJBgEbre0ZtAoGhQiAI0FB9rihsIDBaCAQBGq3vGbUJBIYKgSBAQ/W5orCBwGghEARotL5n1CYQGCoEggAN1eeKwgYCo4VAEKDR+p5Rm0BgqBAIAjRUnysKGwiMFgJBgEbre0ZtAoGhQiAI0FB9rihsIDBaCAQBGq3vGbUJBIYKgf8HZWZke+DqBqwAAAAASUVORK5CYII=" /></p>
<p>This plot shows that the students who have a sibling in the lottery have a higher probability of assignment. The more simulations, the more precise the estimate of the probability of assignment.</p>
</div>
<div id="save-your-random-assignment" class="section level2">
<h2>Save your random assignment</h2>
<p>Whenever you conduct a random assignment for use in an experiment, save it! At a minimum, the random assignment should be saved with an id variable in a csv.</p>
<pre class="sourceCode r"><code class="sourceCode r">hec &lt;-<span class="st"> </span><span class="kw">within</span>(hec,{
  Z_blocked &lt;-<span class="st"> </span><span class="kw">complete_ra</span>(<span class="dt">N =</span> N, <span class="dt">m_each =</span> <span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">292</span>),
               <span class="dt">condition_names=</span><span class="kw">c</span>(<span class="st">&quot;control&quot;</span>, <span class="st">&quot;placebo&quot;</span>, <span class="st">&quot;treatment&quot;</span>))
  id_var &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="kw">nrow</span>(hec)
})
<span class="kw">write.csv</span>(hec[,<span class="kw">c</span>(<span class="st">&quot;id_var&quot;</span>, <span class="st">&quot;Z_blocked&quot;</span>)], <span class="dt">file=</span><span class="st">&quot;MyRandomAssignment.csv&quot;</span>)</code></pre>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
